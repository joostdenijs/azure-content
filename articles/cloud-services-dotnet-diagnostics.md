<properties 
	pageTitle="How to use diagnostics (.NET) - Azure feature guide" 
	description="Learn how to use diagnostic data in Azure for debugging, measuring performance, monitoring, traffic analysis, and more." 
	services="cloud-services" 
	documentationCenter=".net" 
	authors="rboucher" 
	manager="jwhit" 
	editor=""/>

<tags 
	ms.service="cloud-services" 
	ms.workload="tbd" 
	ms.tgt_pltfrm="na" 
	ms.devlang="dotnet" 
	ms.topic="article" 
	ms.date="04/27/2015" 
	ms.author="robb"/>



# Enabling Diagnostics in Azure Cloud Services and Virtual Machines

Azure Diagnostics 1.2 and 1.3 enable you to collect diagnostic data from a worker role, web role, or virtual machine running in Azure. This guide describes how to use Azure Diagnostics 1.2 and 1.3. For additional in-depth guidance on creating a logging and tracing strategy and using diagnostics and other techniques to troubleshoot problems, see [Troubleshooting Best Practices for Developing Azure Applications][].

## Overview

Azure Diagnostics 1.2 and 1.3 are Azure extensions that enable you to collect diagnostic telemetry data from a worker role, web role, or virtual machine running in Azure. The telemetry data is stored in an Azure storage account and can be used for debugging and troubleshooting, measuring performance, monitoring resource usage, traffic analysis and capacity planning, and auditing. 

Azure Diagnostics 1.2 are for use with Azure SDKs for .NET 2.4 and before. Azure Diagnostics 1.3 are for use with Azure SDKs for .NET 2.5 and later.

If you have used Diagnostics version 1.0 in the past, there are three notable differences compared to Diagnostics 1.2 and 1.3:

1.	Diagnostics 1.2 and 1.3 can be deployed on virtual machines, in addition to cloud services.
2.	Diagnostics 1.0 is part of the Azure SDK and is deployed when you deploy your cloud service. Diagnostics 1.2 and 1.3 are an extension and are deployed separately from your cloud service deployment.
3.	Diagnostics 1.2 and 1.3 enable the collection of ETW and .NET EventSource events.

For a more detailed comparison, see [Comparing Azure Diagnostics Versions][] at the end of this article.

Azure Diagnostics can collect the following types of telemetry:

<table border="1" cellspacing="0" cellpadding="5" style="border: 1px solid #000000;">
<tbody>
	<tr>
			<td style="width: 100px;"><strong>Data Source</strong></td>
			<td><strong>Description</strong></td>
	</tr>
	<tr>
		<td>IIS Logs</td>
		<td>Information about IIS web sites.</td>            
	</tr>
	<tr>
		<td>Azure Diagnostic infrastructure logs</td>
		<td>Information about Diagnostics itself.</td>            
	</tr>
	<tr>
		<td>IIS Failed Request logs	</td>
		<td>Information about failed requests to an IIS site or application.</td>            
	</tr>
	<tr>
		<td>Windows Event logs</td>
		<td>Information sent to the Windows event logging system.</td>            
	</tr>
	<tr>
		<td>Performance counters</td>
		<td>Operating System and custom performance counters.</td>            
	</tr>
	<tr>
		<td>Crash dumps</td>
		<td>Information about the state of the process in the event of an application crash.</td>            
	</tr>
	<tr>
		<td>Custom error logs</td>
		<td>Logs created by your application or service.</td>            
	</tr>
	<tr>
		<td>.NET EventSource</td>
		<td>Events generated by your code using the .NET <a href="http://msdn.microsoft.com/library/system.diagnostics.tracing.eventsource(v=vs.110).aspx">EventSource class</a>.</td>            
	</tr>
	<tr>
		<td>Manifest based ETW</td>
		<td>ETW events generated by any process.</td>            
	</tr>
		
</tbody>
</table>

## How to Enable Diagnostics in a Worker Role

This walk through describes how to implement an Azure worker role that emits telemetry data using the .NET EventSource class. Azure Diagnostics is used to collect the telemetry data and store it in an Azure storage account. When creating a worker role Visual Studio automatically enables Diagnostics 1.0 as part of the solution in Azure SDKs for .NET 2.4 and earlier. The following instructions describe the process for creating the worker role, disabling Diagnostics 1.0 from the solution, and deploying Diagnostics 1.2 or 1.3 to your worker role.

### Pre-requisites
This article assumes you have an Azure subscription and are using Visual Studio 2013 with the Azure SDK. If you do not have an Azure subscription, you can sign up for the [Free Trial][]. Make sure to [Install and configure Azure PowerShell version 0.8.7 or later][].

### Step 1: Create a Worker Role
1.	Launch **Visual Studio 2013**.
2.	Create a new **Azure Cloud Service** project from the **Cloud** template that targets .NET Framework 4.5.  Name the project "WadExample" and click Ok.
3.	Select **Worker Role** and click Ok. The project will be created. 
4.	In **Solution Explorer**, double-click on the **WorkerRole1** properties file.
5.	In the **Configuration** tab un-check **Enable Diagnostics** to disable Diagnostics 1.0 (Azure SDK 2.4 and eariler).
6.	Build your solution to verify that you have no errors.

### Step 2: Instrument your code
Replace the contents of WorkerRole.cs with the following code. The class SampleEventSourceWriter, inherited from the [EventSource Class][], implements four logging methods: **SendEnums**, **MessageMethod**, **SetOther** and **HighFreq**. The first parameter to the **WriteEvent** method defines the ID for the respective event. The Run method implements an infinite loop that calls each of the logging methods implemented in the **SampleEventSourceWriter** class every 10 seconds.

	using Microsoft.WindowsAzure.ServiceRuntime;
	using System;
	using System.Diagnostics;
	using System.Diagnostics.Tracing;
	using System.Net;
	using System.Threading;

	namespace WorkerRole1
	{
    sealed class SampleEventSourceWriter : EventSource
    {
        public static SampleEventSourceWriter Log = new SampleEventSourceWriter();
        public void SendEnums(MyColor color, MyFlags flags) { if (IsEnabled())  WriteEvent(1, (int)color, (int)flags); }// Cast enums to int for efficient logging.
        public void MessageMethod(string Message) { if (IsEnabled())  WriteEvent(2, Message); }
        public void SetOther(bool flag, int myInt) { if (IsEnabled())  WriteEvent(3, flag, myInt); }
        public void HighFreq(int value) { if (IsEnabled()) WriteEvent(4, value); }

    }

    enum MyColor
    {
        Red,
        Blue,
        Green
    }

    [Flags]
    enum MyFlags
    {
        Flag1 = 1,
        Flag2 = 2,
        Flag3 = 4
    }

    public class WorkerRole : RoleEntryPoint
    {
        public override void Run()
        {
            // This is a sample worker implementation. Replace with your logic.
            Trace.TraceInformation("WorkerRole1 entry point called");

            int value = 0;

            while (true)
            {
                Thread.Sleep(10000);
                Trace.TraceInformation("Working");

                // Emit several events every time we go through the loop
                for (int i = 0; i < 6; i++)
                {
                    SampleEventSourceWriter.Log.SendEnums(MyColor.Blue, MyFlags.Flag2 | MyFlags.Flag3);
                }

                for (int i = 0; i < 3; i++)
                {
                    SampleEventSourceWriter.Log.MessageMethod("This is a message.");
                    SampleEventSourceWriter.Log.SetOther(true, 123456789);
                }

                if (value == int.MaxValue) value = 0;
                SampleEventSourceWriter.Log.HighFreq(value++);
            }
        }

        public override bool OnStart()
        {
            // Set the maximum number of concurrent connections 
            ServicePointManager.DefaultConnectionLimit = 12;

            // For information on handling configuration changes
            // see the MSDN topic at http://go.microsoft.com/fwlink/?LinkId=166357.

            return base.OnStart();
        }
    }
	}


### Step 3: Deploy your Worker Role
1.	Deploy your worker role to Azure from within Visual Studio by selecting the **WadExample** project in the Solution Explorer then **Publish** from the **Build** menu.
2.	Choose your subscription.
3.	In the **Microsoft Azure Publish Settings** dialog select **Create New…**.
4.	In the **Create Cloud Service and Storage Account** dialog enter a **Name** (for example, "WadExample") and select a region or affinity group.
5.	Set the **Environment** to **Staging**.
6.	Modify any other **Settings** as appropriate and click **Publish**.
7.	After deployment has completed verify in the Azure Portal that your cloud service is in a **Running** state.

### Step 4: Create your Diagnostics configuration file and install the extension
1.	Download the public configuration file schema definition by executing the following PowerShell command:
2.	
		(Get-AzureServiceAvailableExtension -ExtensionName 'PaaSDiagnostics' -ProviderNamespace 'Microsoft.Azure.Diagnostics').PublicConfigurationSchema | Out-File -Encoding utf8 -FilePath 'WadConfig.xsd' 

2.	Add an XML file to your **WorkerRole1** project by right-clicking on the **WorkerRole1** project and select **Add** -> **New Item…** -> **Visual C# items** -> **Data** -> **XML File**. Name the file "WadExample.xml".

	![CloudServices_diag_add_xml](./media/cloud-services-dotnet-diagnostics/AddXmlFile.png)

3.	Associate the WadConfig.xsd with the configuration file. Make sure the WadExample.xml editor window is the active window. Press **F4** to open the **Properties** window. Click on the **Schemas** property in the **Properties** window. Click the **…** in the **Schemas** property. Click the **Add…** button and navigate to the location where you saved the XSD file and select the file WadConfig.xsd. Click **OK**.
4.	Replace the contents of the WadExample.xml configuration file with the following XML and save the file. This configuration file defines a couple performance counters to collect: one for CPU utilization and one for memory utilization. Then the configuration defines the four events corresponding to the methods in the SampleEventSourceWriter class.

		<?xml version="1.0" encoding="utf-8"?>
		<PublicConfig xmlns="http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration">
  			<WadCfg>
    			<DiagnosticMonitorConfiguration overallQuotaInMB="25000">
      			<PerformanceCounters scheduledTransferPeriod="PT1M">
        			<PerformanceCounterConfiguration counterSpecifier="\Processor(_Total)\% Processor Time" sampleRate="PT1M" unit="percent" />
        			<PerformanceCounterConfiguration counterSpecifier="\Memory\Committed Bytes" sampleRate="PT1M" unit="bytes"/>
      				</PerformanceCounters>
      				<EtwProviders>
        				<EtwEventSourceProviderConfiguration provider="SampleEventSourceWriter" scheduledTransferPeriod="PT5M">
          					<Event id="1" eventDestination="EnumsTable"/>
          					<Event id="2" eventDestination="MessageTable"/>
          					<Event id="3" eventDestination="SetOtherTable"/>
          					<Event id="4" eventDestination="HighFreqTable"/>
          					<DefaultEvents eventDestination="DefaultTable" />
        				</EtwEventSourceProviderConfiguration>
      				</EtwProviders>
    			</DiagnosticMonitorConfiguration>
  			</WadCfg>
		</PublicConfig>

### Step 5: Install Diagnostics on your Worker Role
The PowerShell cmdlets for managing Diagnostics on a web or worker role are: Set-AzureServiceDiagnosticsExtension, Get-AzureServiceDiagnosticsExtension, and Remove-AzureServiceDiagnosticsExtension.

1.	Open Azure PowerShell.
2.	Execute the script to install Diagnostics on your worker role (replace *StorageAccountKey* with the storage account key for your wadexample storage account):

		$storage_name = "wadexample"
		$key = "<StorageAccountKey>"
		$config_path="c:\users\<user>\documents\visual studio 2013\Projects\WadExample\WorkerRole1\WadExample.xml"
		$service_name="wadexample"
		$storageContext = New-AzureStorageContext -StorageAccountName $storage_name -StorageAccountKey $key 
		Set-AzureServiceDiagnosticsExtension -StorageContext $storageContext -DiagnosticsConfigurationPath $config_path -ServiceName $service_name -Slot Staging -Role WorkerRole1


### Step 6: Look at your telemetry data
In the Visual Studio **Server Explorer** navigate to the wadexample storage account. After the cloud service has been running about 5 minutes you should see the tables **WADEnumsTable**, **WADHighFreqTable**, **WADMessageTable**, **WADPerformanceCountersTable** and **WADSetOtherTable**. Double-click on one of the tables to view the telemetry that has been collected.
	![CloudServices_diag_tables](./media/cloud-services-dotnet-diagnostics/WadExampleTables.png)

## How to Enable Diagnostics in a Virtual Machine

This walk through describes how to remotely install Diagnostics to an Azure virtual machine from a development computer. You also learn how to implement an application that runs on that Azure virtual machine and emits telemetry data using the .NET [EventSource Class][]. Azure Diagnostics is used to collect the telemetry and store it in an Azure storage account.

### Pre-requisites
This walk through assumes you have an Azure subscription and are using Visual Studio 2013 with the Azure SDK. If you do not have an Azure subscription, you can sign up for the [Free Trial][]. Make sure to [Install and configure Azure PowerShell version 0.8.7 or later][].

### Step 1: Create a Virtual Machine
1.	On your development computer, launch Visual Studio 2013.
2.	In the Visual Studio **Server Explorer** expand **Azure**, right-click **Virtual Machines** then select **Create Virtual Machine**.
3.	Select your Azure subscription in the **Choose a Subscription** dialog and click **Next**.
4.	Select **Windows Server 2012 R2 Datacenter, November 2014** in the **Select a Virtual Machine Image** dialog and click **Next**.
5.	In the **Virtual Machine Basic Settings**, set the virtual machine name to "wadexample". Set your Administrator user name and password and click **Next**.
6.	In the **Cloud Service Settings** dialog create a new cloud service named "wadexampleVM". Create a new Storage account named "wadexample" and click **Next**.
7.	Click **Create**.

### Step 2: Create your Application
1.	On your development computer, launch Visual Studio 2013.
2.	Create a new Visual C# Console Application that targets .NET Framework 4.5. Name the project "WadExampleVM".
	![CloudServices_diag_new_project](./media/cloud-services-dotnet-diagnostics/NewProject.png)
3.	Replace the contents of Program.cs with the following code. The class **SampleEventSourceWriter** implements four logging methods: **SendEnums**, **MessageMethod**, **SetOther** and **HighFreq**. The first parameter to the WriteEvent method defines the ID for the respective event. The Run method implements an infinite loop that calls each of the logging methods implemented in the **SampleEventSourceWriter** class every 10 seconds.

		using System;
		using System.Diagnostics;
		using System.Diagnostics.Tracing;
		using System.Threading;

		namespace WadExampleVM
		{
    	sealed class SampleEventSourceWriter : EventSource
    	{
        	public static SampleEventSourceWriter Log = new SampleEventSourceWriter();
        	public void SendEnums(MyColor color, MyFlags flags) { if (IsEnabled())  WriteEvent(1, (int)color, (int)flags); }// Cast enums to int for efficient logging.
        	public void MessageMethod(string Message) { if (IsEnabled())  WriteEvent(2, Message); }
        	public void SetOther(bool flag, int myInt) { if (IsEnabled())  WriteEvent(3, flag, myInt); }
        	public void HighFreq(int value) { if (IsEnabled()) WriteEvent(4, value); }

    	}

    	enum MyColor
    	{
        	Red,
        	Blue,
        	Green
    	}

    	[Flags]
    	enum MyFlags
    	{
        	Flag1 = 1,
        	Flag2 = 2,
        	Flag3 = 4
    	}

    	class Program
    	{
        static void Main(string[] args)
        {
            Trace.TraceInformation("My application entry point called");
            
            int value = 0;

            while (true)
            {
                Thread.Sleep(10000);
                Trace.TraceInformation("Working");

                // Emit several events every time we go through the loop
                for (int i = 0; i < 6; i++)
                {
                    SampleEventSourceWriter.Log.SendEnums(MyColor.Blue, MyFlags.Flag2 | MyFlags.Flag3);
                }

                for (int i = 0; i < 3; i++)
                {
                    SampleEventSourceWriter.Log.MessageMethod("This is a message.");
                    SampleEventSourceWriter.Log.SetOther(true, 123456789);
                }

                if (value == int.MaxValue) value = 0;
                SampleEventSourceWriter.Log.HighFreq(value++);
            }

        }
    	}
		}


4.	Save the file and select **Build Solution** from the **Build** menu to build your code.


### Step 3: Deploy your Application
1.	Right-click on the **WadExampleVM** project in **Solution Explorer** and choose **Open Folder in File Explorer**.
2.	Navigate to the *bin\Debug* folder and copy all the files (WadExampleVM.*)
3.	In **Server Explorer** right-click on the virtual machine and choose **Connect using Remote Desktop**.
4.	Once connected to the VM create a folder named WadExampleVM and paste your application files into the folder.
5.	Launch the application WadExampleVM.exe. You should see a blank console window.

### Step 4: Create your Diagnostics configuration and install the Extension
1.	Download the public configuration file schema definition to your development computer by executing the following PowerShell command:

		(Get-AzureServiceAvailableExtension -ExtensionName 'PaaSDiagnostics' -ProviderNamespace 'Microsoft.Azure.Diagnostics').PublicConfigurationSchema | Out-File -Encoding utf8 -FilePath 'WadConfig.xsd' 

2.	Open a new XML file in Visual Studio, either in a project you already have open or in a Visual Studio instance with no open projects. In Visual Studio, select **Add** -> **New Item…** -> **Visual C# items** -> **Data** -> **XML File**. Name the file "WadExample.xml"
3.	Associate the WadConfig.xsd with the configuration file. Make sure the WadExample.xml editor window is the active window. Press **F4** to open the **Properties** window. Click on the **Schemas** property in the **Properties** window. Click the **…** in the **Schemas** property. Click the **Add…** button and navigate to the location where you saved the XSD file and select the file WadConfig.xsd. Click **OK**.
4.	Replace the contents of the WadExample.xml configuration file with the following XML and save the file. This configuration file defines a couple performance counters to collect: one for CPU utilization and one for memory utilization. Then the configuration defines the four events corresponding to the methods in the SampleEventSourceWriter class.

		<?xml version="1.0" encoding="utf-8"?>
		<PublicConfig xmlns="http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration">
  			<WadCfg>
    			<DiagnosticMonitorConfiguration overallQuotaInMB="25000">
      			<PerformanceCounters scheduledTransferPeriod="PT1M">
        			<PerformanceCounterConfiguration counterSpecifier="\Processor(_Total)\% Processor Time" sampleRate="PT1M" unit="percent" />
        			<PerformanceCounterConfiguration counterSpecifier="\Memory\Committed Bytes" sampleRate="PT1M" unit="bytes"/>
      				</PerformanceCounters>
      				<EtwProviders>
        				<EtwEventSourceProviderConfiguration provider="SampleEventSourceWriter" scheduledTransferPeriod="PT5M">
          					<Event id="1" eventDestination="EnumsTable"/>
          					<Event id="2" eventDestination="MessageTable"/>
          					<Event id="3" eventDestination="SetOtherTable"/>
          					<Event id="4" eventDestination="HighFreqTable"/>
          					<DefaultEvents eventDestination="DefaultTable" />
        				</EtwEventSourceProviderConfiguration>
      				</EtwProviders>
    			</DiagnosticMonitorConfiguration>
  			</WadCfg>
		</PublicConfig>


### Step 5: Remotely install Diagnostics on your Azure Virtual Machine
The PowerShell cmdlets for managing Diagnostics on a VM are: Set-AzureVMDiagnosticsExtension, Get-AzureVMDiagnosticsExtension, and Remove-AzureVMDiagnosticsExtension.

1.	On your developer computer, open Azure PowerShell.
2.	Execute the script to remotely install Diagnostics on your VM (Replace *StorageAccountKey* with the storage account key for your wadexamplevm storage account):

		$storage_name = "wadexamplevm"
		$key = "<StorageAccountKey>"
		$config_path="c:\users\<user>\documents\visual studio 2013\Projects\WadExampleVM\WadExampleVM\WadExample.xml"
		$service_name="wadexamplevm"
		$vm_name="WadExample"
		$storageContext = New-AzureStorageContext -StorageAccountName $storage_name -StorageAccountKey $key 
		$VM1 = Get-AzureVM -ServiceName $service_name -Name $vm_name
		$VM2 = Set-AzureVMDiagnosticsExtension -DiagnosticsConfigurationPath $config_path -Version "1.*" -VM $VM1 -StorageContext $storageContext
		$VM3 = Update-AzureVM -ServiceName $service_name -Name $vm_name -VM $VM2.VM


### Step 6: Look at your telemetry data
In the Visual Studio **Server Explorer** navigate to the wadexample storage account. After the VM has been running about 5 minutes you should see the tables **WADEnumsTable**, **WADHighFreqTable**, **WADMessageTable**, **WADPerformanceCountersTable** and **WADSetOtherTable**. Double-click on one of the tables to view the telemetry that has been collected.
	![CloudServices_diag_wadexamplevm_tables](./media/cloud-services-dotnet-diagnostics/WadExampleVMTables.png)

## Configuration File Schema

The Diagnostics configuration file defines values that are used to initialize diagnostic configuration settings when the diagnostics monitor starts. A sample configuration file and detailed documentation on its schema is located here: [Azure Diagnostics 1.2 Configuration Schema][].

## Troubleshooting

### Azure Diagnostics is not Starting
Diagnostics is comprised of two components: A guest agent plugin and the monitoring agent. Log files for the guest agent plugin are located in the file: 

*%SystemDrive%\ WindowsAzure\Logs\Plugins\Microsoft.Azure.Diagnostics.PaaSDiagnostics\<DiagnosticsVersion>*\CommandExecution.log

The following error codes are returned by the plugin:

<table border="1" cellspacing="0" cellpadding="5" style="border: 1px solid #000000;">
<tbody>
	<tr>
			<td style="width: 100px;"><strong>Exit Code</strong></td>
			<td><strong>Description</strong></td>
	</tr>
    <tr>
		<td>0</td>
		<td>Success.</td>            
	</tr>
    <tr>
		<td>-1</td>
        <td>Generic Error.</td>		            
	</tr>
    <tr>
		<td>-2</td>
        <td><p>Unable to load the rcf file.</p>
<p>This is an internal error that should only happen if the guest agent plugin launcher is manually invoked, incorrectly, on the VM.</p></td>		            
	</tr>
    <tr>
		<td>-3</td>
        <td><p>Cannot load the Diagnostics configuration file.</p>
<p>Solution: This is the result of a configuration file not passing schema validation. The solution is to provide a configuration file that complies with the schema.</p></td>		            
	</tr>
    <tr>
		<td>-4</td>
        <td><p>Another instance of the monitoring agent Diagnostics is already using the local resource directory.</p>
<p>Solution: Specify a different value for <strong>LocalResourceDirectory</strong>.</p></td>		            
	</tr>
    <tr>
		<td>-6</td>
        <td><p>The guest agent plugin launcher attempted to launch Diagnostics with an invalid command line.</p>
<p>This is an internal error that should only happen if the guest agent plugin launcher is manually invoked, incorrectly, on the VM.</p></td>		            
	</tr>
    <tr>
		<td>-10</td>
        <td>The Diagnostics plugin exited with an unhandled exception.</td>		            
	</tr>
    <tr>
		<td>-11</td>
        <td><p>The guest agent was unable to create the process responsible for launching and monitoring the monitoring agent.</p>

<p>Solution: Verify that sufficient system resources are available to launch new processes.</p></td>		            
	</tr>
    <tr>
		<td>-101</td>
        <td><p>Invalid arguments when calling the Diagnostics plugin.</p>

<p>This is an internal error that should only happen if the guest agent plugin launcher is manually invoked, incorrectly, on the VM.</p></td>		            
	</tr>
    <tr>
		<td>-102</td>
        <td><p>The plugin process is unable to initialize itself.</p> 

<p>Solution: Verify that sufficient system resources are available to launch new processes.</p></td>		            
	</tr>
    <tr>
		<td>-103</td>
        <td><p>The plugin process is unable to initialize itself. Specifically it is unable to create the logger object.</p>

<p>Solution: Verify that sufficient system resources are available to launch new processes.</p></td>		            
	</tr>
    <tr>
		<td>-104</td>
        <td><p>Unable to load the rcf file provided by the guest agent.</p>

<p>This is an internal error that should only happen if the guest agent plugin launcher is manually invoked, incorrectly, on the VM.</p></td>		            
	</tr>
    <tr>
		<td>-105</td>
        <td><p>The Diagnostics plugin cannot open the Diagnostics configuration file.</p>

<p>This is an internal error that should only happen if the Diagnostics plugin is manually invoked, incorrectly, on the VM.</p></td>		            
	</tr>
    <tr>
		<td>-106</td>
        <td><p>Cannot read the Diagnostics configuration file.</p>

<p>Solution: This is the result of a configuration file not passing schema validation. So the solution is to provide a configuration file that complies with the schema. You can find the XML that is delivered to the Diagnostics extension in the folder <i>%SystemDrive%\WindowsAzure\Config</i> on the VM. Open the appropriate XML file and search for <strong>Microsoft.Azure.Diagnostics</strong>, then for the <strong>xmlCfg</strong> field. The data is base64 encoded so you’ll need to <a href="http://www.bing.com/search?q=base64+decoder">decode it</a> to see the XML that was loaded by Diagnostics.</p></td>		            
	</tr>
    <tr>
		<td>-107</td>
        <td><p>The resource directory pass to the monitoring agent is invalid.</p>

<p>This is an internal error that should only happen if the monitoring agent is manually invoked, incorrectly, on the VM.</p></td>		            
	</tr>
    <tr>
		<td>-108	</td>
        <td><p>Unable to convert the Diagnostics configuration file into the monitoring agent configuration file.</p>

<p>This is an internal error that should only happen if the Diagnostics plugin is manually invoked with an invalid configuration file.</p></td>		            
	</tr>
    <tr>
		<td>-110</td>
        <td><p>General Diagnostics configuration error.</p>

<p>This is an internal error that should only happen if the Diagnostics plugin is manually invoked with an invalid configuration file.</p></td>		            
	</tr>
    <tr>
		<td>-111</td>
        <td><p>Unable to start the monitoring agent.</p>

<p>Solution: Verify that sufficient system resources are available.</p></td>		            
	</tr>
    <tr>
		<td>-112</td>
        <td>General error</td>		            
	</tr>    
</tbody>
</table>

### Diagnostics Data is Not Logged to Storage
The most common cause of missing event data is incorrectly defined storage account information. 

Solution: Correct your Diagnostics configuration file and re-install Diagnostics.
Before event data is uploaded to your storage account it is stored in the folder. See above for details on **LocalResourceDirectory**.

If there are no files in this folder the monitoring agent is unable to launch. This is typically caused by an invalid configuration file and should have been reported in the CommandExecution.log. If the Monitoring Agent is successfully collecting event data you will see .tsf files for each event defined in your configuration file.

The Monitoring Agent logs any errors it experiences in the file MaEventTable.tsf. To inspect the contents of this file run the following command:

		%SystemDrive%\Packages\Plugins\Microsoft.Azure.Diagnostics.[IaaS | PaaS]Diagnostics\1.3.0.0\Monitor\x64\table2csv maeventtable.tsf

The tool generates a file named maeventtable.csv that you may open and inspect the logs for failures.


## Frequently Asked Questions
The following are some frequently asked questions and their answers:

**Q.** How do I upgrade my Visual Studio solution from Azure Diagnostics 1.0 to Azure Diagnostics 1.1?

**A.** Upgrading your Visual Studio solution from Diagnostics 1.0 to Diagnostics 1.1 (or later) is a manual process:
- Disable Diagnostics in your Visual Studio solution to prevent Diagnostics 1.0 from being deployed with your role
- If your code uses Trace Listener you will need to modify your code to use .NET EventSource. Diagnostics 1.1 and later does not support Trace Listener.
- Modify your deployment process to install the Diagnostics 1.1 extension

**Q.** If I have already installed the Diagnostics 1.1 Extension on my role or VM how do I upgrade to Diagnostics 1.2 or 1.3?

**A.** If you specified “–Version “1.*”" when you installed Diagnostics 1.1, the next time your role restarts or the VM reboots it will be automatically updated to the most recent version matching the regular expression “1.*” If “–Version “1.1”” when you installed Diagnostics 1.1 you can update a newer version be re-executing the Set- cmdlet and specifying the version you want to install.

**Q.** How are tables named?

**A.** Tables are named according to the following:

		if (String.IsNullOrEmpty(eventDestination)) {
		    if (e == "DefaultEvents")
		        tableName = "WADDefault" + MD5(provider);
		    else
		        tableName = "WADEvent" + MD5(provider) + eventId;
		}
		else
		    tableName = "WAD" + eventDestination;

Here is an example:

		<EtwEventSourceProviderConfiguration provider=”prov1”>
		  <Event id=”1” />
		  <Event id=”2” eventDestination=”dest1” />
		  <DefaultEvents />
		</EtwEventSourceProviderConfiguration>
		<EtwEventSourceProviderConfiguration provider=”prov2”>
		  <DefaultEvents eventDestination=”dest2” />
		</EtwEventSourceProviderConfiguration>

That will generate 4 tables:

<table border="1" cellspacing="0" cellpadding="5" style="border: 1px solid #000000;">
<tbody>
	<tr>
			<td style="width: 100px;"><strong>Event</strong></td>
			<td><strong>Table Name</strong></td>			
	</tr>
	<tr>
			<td>provider=”prov1” &lt;Event id=”1” /&gt;</td>
			<td>WADEvent+MD5(“prov1”)+”1”</td>			
	</tr>
	<tr>
			<td>provider=”prov1” &lt;Event id=”2” eventDestination=”dest1” /&gt;</td>
			<td>WADdest1</td>			
	</tr>
	<tr>
			<td>provider=”prov1” &lt;DefaultEvents /&gt;</td>
			<td>WADDefault+MD5(“prov1”)</td>			
	</tr>
	<tr>
			<td>provider=”prov2” &lt;DefaultEvents eventDestination=”dest2” /&gt;</td>
			<td>WADdest2</td>			
	</tr>
	

</table>
</tbody>

## Comparing Azure Diagnostics Versions

The following table compare the features supported by Azure Diagnostics versions 1.0 and 1.1/1.2/1.3:

<table border="1" cellspacing="0" cellpadding="5" style="border: 1px solid #000000;">
<tbody>
	<tr>
			<td style="width: 100px;"><strong>Role Types Supported</strong></td>
			<td><strong>Diagnostics 1.0</strong></td>
			<td><strong>Diagnostics 1.1/1.2/1.3</strong></td>
	</tr>

	<tr>
			<td>Web role</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>Worker role</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>IaaS</td>
			<td>No</td>
			<td>Yes</td>
	</tr>
</tbody>
</table>

<table border="1" cellspacing="0" cellpadding="5" style="border: 1px solid #000000;">
<tbody>
	<tr>
			<td style="width: 100px;"><strong>Configuration and deployment</strong></td>
			<td><strong>Diagnostics 1.0</strong></td>
			<td><strong>Diagnostics 1.1/1.2/1.3</strong></td>
	</tr>

	<tr>
			<td>Integration with Visual Studio- Integrated into the Azure web/worker development experience.</td>
			<td>Yes</td>
			<td>No</td>
	</tr>
	<tr>
			<td>PowerShell Scripts- Scripts to manage the installation and configuration of Diagnostics on the role.</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	
</tbody>
</table>

<table border="1" cellspacing="0" cellpadding="5" style="border: 1px solid #000000;">
<tbody>
	<tr>
			<td style="width: 100px;"><strong>Data Source</strong></td>
			<td><strong>Default Collection</strong></td>
			<td><strong>Format</strong></td>
			<td><strong>Description</strong></td>
			<td><strong>Diagnostics 1.0</strong></td>
			<td><strong>Diagnostics 1.1/1.2</strong></td>
			<td><strong>Diagnostics 1.3</strong></td>
	</tr>
	<tr>
			<td>System.Diagnostics.Trace Logs</td>
			<td>Yes</td>
			<td>Table</td>
			<td>Logs trace messages sent from your code to the trace listener (a trace listener must be added to the web.config or app.config file). Log data will be transferred at the scheduledTransferPeriod transfer interval to storage table WADLogsTable.</td>
			<td>Yes</td>
			<td>No (Use EventSource)</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>IIS logs</td>
			<td>Yes</td>
			<td>Blob</td>
			<td>Logs information about IIS sites. Log data will be transferred at the scheduledTransferPeriod transfer interval to the container you specify.</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>Azure Diagnostic infrastructure logs</td>
			<td>Yes</td>
			<td>Table</td>
			<td>Logs information about the diagnostic infrastructure, the RemoteAccess module, and the RemoteForwarder module. Log data will transferred at the scheduledTransferPeriodtransfer interval to storage table WADDiagnosticInfrastructureLogsTable.</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>IIS Failed Request logs</td>
			<td>No</td>
			<td>Blob</td>
			<td>Logs information about failed requests to an IIS site or application. You must also enable by setting tracing options under system.WebServer in Web.config. Log data will be transferred at the scheduledTransferPeriod transfer interval to the container you specify.</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>Windows Event logs</td>
			<td>No</td>
			<td>Table</td>
			<td>Logs information about how well the operating system, application, or driver is performing. Performance counters must be specified explicitly. When these are added, performance counter data will be transferred at the scheduledTransferPeriod transfer interval to storage table WADPerformanceCountersTable.</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>Performance counters</td>
			<td>No</td>
			<td>Table</td>
			<td>Logs information about how well the operating system, application, or driver is performing. Performance counters must be specified explicitly. When these are added, performance counter data will be transferred at the scheduledTransferPeriod transfer interval to storage table WADPerformanceCountersTable.</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>Crash dumps</td>
			<td>No</td>
			<td>Blob</td>
			<td>Logs information about the state of the operating system in the event of a system crash. Mini crash dumps are collected locally. Full dumps can be enabled. Log data will be transferred at the scheduledTransferPeriod transfer interval to the container you specify. Because ASP.NET handles most exceptions, this is generally useful only for a worker role or a VM.</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>Custom error logs</td>
			<td>No</td>
			<td>Blob</td>
			<td>By using local storage resources, custom data can be logged and transferred immediately to the container you specify.</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>EventSource</td>
			<td>No</td>
			<td>Table</td>
			<td>Logs events generated by your code using the .NET EventSource class.</td>
			<td>No</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
	<tr>
			<td>Manifest based ETW</td>
			<td>No</td>
			<td>Table</td>
			<td>ETW events generated by any process.</td>
			<td>No</td>
			<td>Yes</td>
			<td>Yes</td>
	</tr>
</tbody>
</table>

## Additional Resources

- [Troubleshooting Best Practices for Developing Azure Applications][]
- [Collect Logging Data by Using Azure Diagnostics][]
- [Debugging an Azure Application][]
- [Configuring Diagnostics for Azure Cloud Services and Virtual Machines][]

  

[Overview]: #overview
[How to Enable Diagnostics in a Worker Role]: #worker-role
[How to Enable Diagnostics in a Virtual Machine]: #virtual-machine
[Sample Configuration File and Schema]: #configuration-file-schema
[Troubleshooting]: #troubleshooting
[Frequently Asked Questions]: #faq
[Comparing Azure Diagnostics Versions]: #comparing
[Additional Resources]: #additional
[EventSource Class]: http://msdn.microsoft.com/library/system.diagnostics.tracing.eventsource(v=vs.110).aspx
  
[Configuring Diagnostics for Azure Cloud Services and Virtual Machines]: http://msdn.microsoft.com/library/windowsazure/dn186185.aspx
[Debugging an Azure Application]: http://msdn.microsoft.com/library/windowsazure/ee405479.aspx   
[Collect Logging Data by Using Azure Diagnostics]: http://msdn.microsoft.com/library/windowsazure/gg433048.aspx
[Troubleshooting Best Practices for Developing Azure Applications]: http://msdn.microsoft.com/library/windowsazure/hh771389.aspx
[Free Trial]: http://azure.microsoft.com/pricing/free-trial/
[Install and configure Azure PowerShell version 0.8.7 or later]: http://azure.microsoft.com/documentation/articles/install-configure-powershell/
[Azure Diagnostics 1.2 Configuration Schema]: http://msdn.microsoft.com/library/azure/dn782207.aspx
[Set-AzureServiceDiagnosticsExtension]: http://msdn.microsoft.com/library/dn495270.aspx
[Get-AzureServiceDiagnosticsExtension]: http://msdn.microsoft.com/library/dn495145.aspx
[Remove-AzureServiceDiagnosticsExtension]: http://msdn.microsoft.com/library/dn495168.aspx
